{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang16393{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset1 Cambria Math;}{\f2\fnil\fcharset0 Cambria Math;}{\f3\fnil\fcharset2 Wingdings;}}
{\*\generator Riched20 10.0.19041}{\*\mmathPr\mmathFont1\mwrapIndent1440 }\viewkind4\uc1 
\pard\sl240\slmult1\b\f0\fs22\lang9 Python:\b0\par
\par
Python is a high-level, interpreted, interactive and object-oriented scripting language. Python is designed to be highly readable. It uses English keywords frequently where as other languages use punctuation, and it has fewer syntactical constructions than other languages.\par
Python is Interpreted \f1\u8722?\f0  Python is processed at runtime by the interpreter. You do not need to compile your program before executing it. This is similar to PERL and PHP.\par
\par
Python is Interactive \f1\u8722?\f0  You can actually sit at a Python prompt and interact with the interpreter directly to write your programs.\par
\par
Python is Object-Oriented \f1\u8722?\f0  Python supports Object-Oriented style or technique of programming that encapsulates code within objects.\par
\par
Python is a Beginner's Language \f1\u8722?\f0  Python is a great language for the beginner-level programmers and supports the development of a wide range of applications from simple text processing to WWW browsers to games.\par
\par
\b Characteristics\f2  \f0 of\f2  \f0 Python:\par
\b0\par
Following\f2  \f0 are\f2  \f0 important\f2  \f0 characteristics\f2  \f0 of\f2  \f0 Python\f2  \f0 Programming\f2  \f1\u8722?\f0\par
\par
It\f2  \f0 supports\f2  \f0 functional\f2  \f0 and\f2  \f0 structured\f2  \f0 programming\f2  \f0 methods\f2  \f0 as\f2  \f0 well\f2  \f0 as\f2  \f0 OOP\f2 .\f0\par
\par
It\f2  \f0 can\f2  \f0 be\f2  \f0 used\f2  \f0 as\f2  \f0 a\f2  \f0 scripting\f2  \f0 language\f2  \f0 or\f2  \f0 can\f2  \f0 be\f2  \f0 compiled\f2  \f0 to\f2  \f0 byte\f2 -\f0 code\f2  \f0 for\f2  \f0 building\f2  \f0 large\f2  \f0 applications\f2 .\f0\par
\par
It\f2  \f0 provides\f2  \f0 very\f2  \f0 high\f2 -\f0 level\f2  \f0 dynamic\f2  \f0 data\f2  \f0 types\f2  \f0 and\f2  \f0 supports\f2  \f0 dynamic\f2  \f0 type\f2  \f0 checking\f2 .\f0\par
\par
It\f2  \f0 supports\f2  \f0 automatic\f2  \f0 garbage\f2  \f0 collection\f2 .\f0\par
\par
It\f2  \f0 can\f2  \f0 be\f2  \f0 easily\f2  \f0 integrated\f2  \f0 with\f2  \f0 C\f2 , \f0 C\f2 ++, \f0 COM\f2 , \f0 ActiveX\f2 , \f0 CORBA\f2 , \f0 and\f2  \f0 Java\f2 .\par
\par
\par
\b Important Characters and Sets of Characters\b0\par
\f3\'b7\f2  tab \\t\par
\f3\'b7\f2  new line \\n\par
\f3\'b7\f2  backslash \\\\\par
\f3\'b7\f2  string " " or ' '\par
\f3\'b7\f2  docstring """ """\par
\f3\'b7\f2  comparison operators == , < , > , <= , >= , !=\par
\f3\'b7\f2  Python type boolean True , False.\par
\f3\'b7\f2  Logical operators not , and , or\par
\par
\b Variable Names\par
\b0\f3\'b7\f2  case sensitive\par
\f3\'b7\f2  cannot start with a number (ex, 1_assd is not allowed)\par
\par
\b\par
Six Steps to Defining a Function\par
\b0 1. What should your function do? Type a couple of example calls.\par
2. Pick a meaningful name (often a verb or verb phrase): What is a short answer to "What does\par
your function do"?\par
3. Decide how many parameters the function takes and any return values\par
4. Describe what your function does and any parameters and return values in the docstring\par
5. Write the body of the function\par
6. Test your function. Think about edge cases.\par
\par
\par
\b Integers and Strings\b0\par
>>> int(45)\par
45\par
>>> int('45')\par
45\par
>>> str(45)\par
'45'\par
>>> str('45')\par
'45'\par
>>> int(str(45))\par
45\par
\par
\par
\b Calling Methods\b0\par
module_name.function_name(x)\par
\f3\'b7\f2  math.sqrt(x)\par
\f3\'b7\f2  random.randrange(2,5)\par
\par
\b Conditionals and Branching\b0\par
\f3\'b7\f2  if\par
\f3\'b7\f2  elif\par
\f3\'b7\f2  else\par
We have a boolean logic expression for if which works when the Boolean evaluates to True\par
\par
\par
\b String Indexing and Slicing\b0\par
(s[a:b] means index a to length (b-a) or a to b index but not including b)\par
\f3\'b7\f2  s[2:3]\par
\f3\'b7\f2  s[0]\par
\f3\'b7\f2  s[:5]\par
\f3\'b7\f2  s[4:]\par
String is immutable (ex. s[4]='a' will not replace 'a' and index 4 of s)\par
\b\par
\par
String Methods\par
\b0\f3\'b7\f2  A method is a function inside of an object.\par
\f3\'b7\f2  The general form of a method call is:\par
o object.method(arguments)\par
o dir(str)\par
o help(str.method)\par
\par
\par
\b for Loops\b0\par
num_vowels = 0\par
 for char in s:\par
 if char in 'aeiouAEIOU':\par
 num_vowels = num_vowels + 1\par
 print num_vowels\par
vowels = ''\par
for char in s:\par
 if char in 'aeiouAEIOU':\par
 vowels = vowels + char\par
print vowels\par
\par
\par
\b Lists\par
\b0\par
Like for strings, slicing and indexing can also be used for lists\par
List = ['a','b',1]\par
\f3\'b7\f2  length of list len(list)\par
\f3\'b7\f2  smallest element in list min(list)\par
\f3\'b7\f2  largest element in list max(list)\par
\f3\'b7\f2  sum of elements of list (where list items must be numeric) sum(list)\par
\par
>>> a=[1,'ab',2,'pq']\par
>>> a[1][0]\par
'a'\par
>>> a[1][1]\par
'b'\par
>>> a[3][1]\par
'q'\par
>>> a[3][2]\par
\par
\b List Methods\par
\b0\f3\'b7\f2  append a value or string list.append('a')\par
\f3\'b7\f2  extended by another list list.extend(['a', 'b'])\par
>>> a = [5] + [6] + ['a',7]\par
>>> print (a)\par
[5, 6, 'a', 7]\par
\par
\par
\b List Mutability\b0\par
We say that lists are mutable: they can be modified.\par
>>> lst = [1, 2, 3]\par
>>> lst[0] = 'apple'\par
>>> lst\par
['appple, 2, 3]\par
\par
\b List Aliasing\b0\par
Consider the following code:\par
>>> lst1 = [11, 12, 13, 14, 15, 16, 17]\par
>>> lst2 = lst1\par
>>> lst1[-1] = 18\par
>>> lst2\par
[11, 12, 13, 14, 15, 16, 18]\par
\par
After the second statement executes, lst1 and lst2 both refer to the same list. When two\par
variables refer to the same objects, they are aliases. If that list is modified, both of lst1 and lst2\par
will see the change.\par
But be careful about:\par
>>> lst1 = [11, 12, 13, 14, 15, 16, 17]\par
>>> lst2 = lst1\par
>>> lst1 = [5, 6]\par
>>> lst2\par
[11, 12, 13, 14, 15, 16, 17]\par
And also:\par
>>> lst1 = [1,2,3]\par
>>> lst2 = lst1[:]\par
>>> lst2.remove(2)\par
>>> lst1\par
[1,2,3]\par
\par
\par
\b while Loops\par
\b0\par
i = 0\par
while i < len(s) and not (s[i] in 'aeiouAEIOU'):\par
 print(s[i])\par
 i = i + 1\par
for char in s:\par
 if not (char in 'aeiouAEIOU'):\par
 print(char)\par
\par
The difference between the two is that the for loop looks at every character in s, but the while\par
loop ends as soon a vowel is found. So the loops differ on any string where a consonant follows a\par
vowel. while is an if statement in motion. It is a repeated loop until the boolean test evaluates to\par
False.\par
def secret(s):\par
 i = 0\par
 result = ''\par
 while s[i].isdigit():\par
 result = result + s[i]\par
 i = i + 1\par
 print result\par
>>> secret('123') will give an error message when it runs the fourth time.\par
\par
\par
\b Global and Local Variables\par
\b0\par
Variables defined outside functions are global variables. Their values may be accessed inside\par
functions without declaration.\par
To modify to a global variable inside a function, the variable must be declared inside the function\par
using the keyword global.\par
def x():\par
 global num\par
 num = 5\par
def y():\par
 num = 4\par
>>> num = 7\par
>>> print (num)\par
7\par
>>> x()\par
>>> print (num)\par
5\par
>>> y()\par
>>> print (num)\par
5\par
\par
\par
\b Dictionaries\b0\par
The values of a dictionary can be of any type, but the keys must be of an immutable data type such\par
as strings, numbers, or tuples.\par
\f3\'b7\f2  keys can be numbers, strings, Booleans\par
o a list is unhashable in a dictionary (cannot be used as a key)\par
o a tuple is hashable in a dictionary (can be used as a key).\par
\f3\'b7\f2  values can be dicts, strings, numbers, booleans, lists\par
for key in my_dict:\par
 value = my_dict[key]\par
This is same as:\par
for key, value in my_dict.items():\par
}
 